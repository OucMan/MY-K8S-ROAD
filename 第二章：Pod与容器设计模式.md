# 1、K8s中的基本调度单位：Pod

## 1.2 Pod概述

Pod容器组是一个k8s中一个抽象的概念，用于存放一组container（可包含一个或多个container容器）。Pod是K8s调度的基本单位，是分配资源的一个单位，也就是说即使当一个Pod包含多个容器时，这些容器也总是会运行在同一个节点上（一个Pod绝不会跨越多个工作节点）。Pod中的容器具有“**超亲密关系**”，

什么叫做超亲密关系呢？大概分为以下几类：

* 比如说两个进程之间会发生文件交换，比如一个写日志，一个读日志；
* 两个进程之间需要通过 localhost 或者说是本地的 Socket 去进行通信，这种本地通信也是超亲密关系；
* 这两个容器或者是微服务之间，需要发生非常频繁的 RPC 调用，出于性能的考虑，也希望它们是超亲密关系；
* 两个容器或者是应用，它们需要共享某些 Linux Namespace。最简单常见的一个例子，就是我有一个容器需要加入另一个容器的 Network Namespace。这样我就能看到另一个容器的网络设备，和它的网络信息。

**一言以蔽之，Pod就是将具有“超亲密关系”的容器绑定在一起，共同调度。**

## 1.3 为什么需要Pod

容器被设计为每一个容器只运行一个进程（除非进程本身产生的子进程）。如果多个不相关进程运行在一个容器中，那么需要做很多的工作，来保证所有进程正常运行，并管理它们的日志（每个进程需要记录哪些信息）等情况，因此每个进程运行与自己的容器，多个进程分别起多个容器，关系紧密的进程，将他们对应的容器归属于同一个Pod，实现方便的管理。

换句话说，多个容器的组合就叫做 Pod。并且还有一个概念一定要非常明确，Pod 是Kubernetes分配资源的一个单位，因为里面的容器要共享某些资源，所以Pod也是 Kubernetes 的原子调度单位。


## 1.4 Pod的实现机制

Pod是一个抽象的概念，它没有具体的实体，它背后其实就是一组可以共享资源的容器，所以Pod要解决的核心问题就是如何让一个Pod里的多个容器之间最高效的共享某些资源和数据。因为容器之间原本是被Linux Namespace和cgroups隔开的，所以现在实际要解决的是怎么去打破这个隔离，然后共享某些事情和某些信息。这就是Pod的设计要解决的核心问题所在。具体的包括共享网络和共享存储。

### 1.4.1 共享网络

比如说现在有一个Pod，其中包含了一个容器A和一个容器B，它们两个就要共享 Network Namespace。在K8s里的解法是这样的：在启动Pod中的业务容器之前，首先提前起一个pause容器，整个Pod的Network Namespace就是这个pause容器的Network Namespace，其他所有容器都会通过Join Namespace的方式加入到pause container的Network Namespace中。所以说一个Pod里面的所有容器，它们看到的网络视图是完全一样的。即：它们看到的网络设备、IP地址、Mac地址等等，跟网络相关的信息，其实全是一份，这一份都来自于Pod第一次创建的这个pause容器。pause容器使用了一个非常小的镜像，大概 100~200KB 左右，是一个汇编语言写的、永远处于“暂停”状态的容器。它是整个Pod中第一个启动的容器，Pod生命周期与pause容器相同，而与其它容器无关，这就允许在K8s中去单独更新Pod里的某一个镜像的，即：做这个操作，整个Pod不会重建，也不会重启。

因为一个Pod中的容器共享网络空间，因此它们共享相同的IP地址和端口空间，这意味着同一个Pod中的容器进程不能绑定到相同的端口号，否则会导致端口冲突，而一个Pod中的容器之间通信可以通过localhost:port来完成。

![Pod共享网络](https://github.com/OucMan/MY-K8S-ROAD/blob/main/pic/pod%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C.png)


### 1.4.2 共享存储

共享存储十分简单，就是Pod中的容器通过挂载同一数据卷volume来实现共享。

## 1.5 K8s对Pod的操作




# 2、容器设计模式

