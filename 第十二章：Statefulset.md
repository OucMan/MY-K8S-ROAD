# 1. StatefulSet

## 1.1 概述

ReplicaSet通过一个模板创建多个Pod，这些副本除了名字和IP地址不同，其它的没有差别，同时这些副本共享持久卷。当某一个Pod由于一些原因被删除，然后被新的Pod替代，那么新的Pod将会有新的主机名和IP。对于有状态应用存在一种需求，即新的Pod和被替换的Pod具有相同的主机名和网络标识，并且具有专属的存储，这时候ReplicaSet就不能满足要求了，为此K8s中提供了StatefulSet控制器来管理Pod。

## 1.2 稳定的网络标识

StatefulSet创建的每一个Pod都有一个从零开始的顺序索引，这会体现在Pod的名称和主机名上，同样也会体现在Pod对应的固定存储上，比如StatefulSet A有三个Pod副本，那么Pod的名字分别是Pod A-0，Pod A-1，和Pod A-2，因此Pod的名字是可以预知的。

有状态的Pod和无状态的Pod还有一个差异性：无状态的Pod都是一样的，在需要的时候随便选一个就好，但是有状态的Pod，因为它们彼此是不同的，通常希望操作的是其中特定的一个，因此需要使用主机名来定位。基于这个原因，一个StatefulSet通常需要创建一个用来记录每个Pod网络标识的headless Service。通过这个Service，每个Pod将拥有独立的DNS记录，这样集群里它的伙伴或者客户端就可以通过主机名找到它。比如一个属于default命名空间，名为foo的控制服务，它的一个Pod名称为A-0，那么可以通过完整域名来访问它：a-0.foo.default.svc.cluster.local，也可以通过DNS服务，查找域名foo.default.svc.cluster.local对应的所有SRV记录，获取一个Statefulset中所有Pod的名称。

### 1.2.1 替换Pod

当StatefulSet管理的一个Pod实例消失后，StatefulSet会保证重启一个新的Pod实例替换它，新的Pod会拥有与之前Pod完全一致的名称和主机名（对于新的Pod运行在哪一个节点并不重要）。

### 1.2.2 扩缩容StatefulSet

扩容一个StatefulSet会使用下一个还没有用到的顺序索引值创建一个新的Pod实例。

缩容一个StatefulSet会最先删除最高索引值的实例，并且缩容在任何时候只会操作一个Pod实例。

注意，StatefulSet在有实例不健康的情况下是不允许缩容的。


## 1.3 稳定的专属存储

一个有状态的Pod需要拥有自己的存储，即使该有状态的Pod被重新调度，新的实例也必须挂载着相同的存储。StatefulSet采用的办法就是使用卷声明模板为每一个Pod都创建持久卷声明，这些持久卷声明会在创建Pod之前创建出来，绑定到一个Pod实例上。持久卷声明对应的持久卷可以是管理员提前创建出来，也可以是由持久卷的动态供应机制实时创建出来。

### 1.3.1 持久卷的创建和删除

扩容StatefulSet增加一个副本数时，会创建一个Pod和与之相关的一个或者多个持久卷声明

缩容StatefulSet时，只会删除一个Pod，而留下之前创建的声明。

### 1.3.2 重新将持久卷挂载到相同Pod的新实例上

因为缩容StatefulSet时会保留持久卷声明，所以在随后的扩容操作时，新的Pod实例会使用绑定在持久卷上的相同声明和其上的数据。




# 2. 演示
